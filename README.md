# 201930121 이명규
## 23.12.07
+ 모든 컴포넌트에 적용할 css 규칙을 만들고 싶으면 global 속성 지정(But 예상치 못한 결과의 유무 조심)
+  CSS in Js 단점 
    - 문법 하이라이팅, 자동완성, lint 기능 제공x
    - IDE 코드 편집기 등 개발도구 지원 부족
    - 앱 번들도 커지고 느려짐
    - 서버에 미리 css 를 생성해도 클라이언트에서 리액트 하이드레이션이 끝나면 css 기능을 다시 실행해야 함 -> 부하 발생 증가

+ css 모듈
    - css in js 의 단점 회피를 위한 수단
    - module.css 로 끝나는 파일에서 css 클래스 가지고옴
    - home.module.css 파일은 일반적인 css 파일이지만 css module이 그 내용을 js 객체로 변환 (변환 모든 키는 클래스 이름 )

+ SASS
    - Next 에서 기본 지원 처리기
    - 패키지 설치 필요<br>
        `$ npm install sass`
    - SASS 및 SCSS(Sassy CSS) 문법으로 CSS Module을 만들고 사용가능
    - SASS 기본 설정을 변경해야 할 경우 next.config.js 설정파일 변경

+ Chakra UI
    - 오픈소스 컴포넌트 라이브럴, 모듈화 되어있고 접근성 좋음
    - 버튼 모달 입력 등 다양한 내장 컴포넌트 제공
    - DARK MODE 및 LIGHT MODE 모두 지원
    - Chakra UI 의 useColorMide 훅 사용해서 현재 사용하는 컬러 모드 확인 가능
    - 기본 컴포넌트를 조합해서 새로운 컴포넌트를 쉽게 만들 수 있음
    - 타입스크립트로 작성

+ Tailwind CSS
    - 다른 프레임워크와는 다르게 css 규칙만을 제공
    - 자바스크립트 모듈이나 리액트 컴포넌트를 제공하지 않기 때문에 필요한 경우 직접 만들어 사용
    - 변수값을 조정해 개성있는 디자인 생성 가능(자유도 높음)
    - DARK MODE 및 LIGHT MODE 모두 지원
    - 빌드 시점에 사용하지 않은 클래스는 제거 되기 때문에 높은 최적화 제공
    - css 클래스의 접두사 활용 하여 모바일 , 데탑, 태블릿 화면에서 원하는 규칙 지정 가능 

+ Headless UI
    - Tailwind LABS 팀에서 개발한 무료 오픈소스 PJ / Tailwind CSS는 웹 컴포넌트 안에서 사용할 수 있는 CSS 제공
    - Headless UI 는 CSS를 제공하는 것이 아니라 동적 컴포넌트만 제공

+ <strong> 커스텀 서버</strong>
    1. 커스텀 서버가 필요한 경우
        + 실제 웹 앱을 만들고 서비스 제공 시 EXPRESS.JS / Fatify 서버에서 앱 실행 경우는 드뭄
        + 일부환경에서의 필요
            - 웹 앱 기존의 서버에서 실행 경우(기존 서버 실행되던 미들웨어등을 최대한 유지하고 싶을 때)
            - 멀티테넌지 지원 필요 경우
            - 더 세밀한 제어 필요 경우(웹 앱 복잡도 증가로 인해 백엔드 코드 다른 방법으로 관리를 원할 때)
        + 단점 : Vercel등에 배표 불가능 / 더 많은 코드 작성 및 유지보수 증가<br>
    
+ <strong>테스트</strong>
    1. 테스트
        - 단위테스트 : 코드의 각 함수가 제대로 작동하는지 확인 테스트
        - 엔드 투 엔드 테스트 : 앱에 대한 사용자 상호 작용을 흉내내서 특정 작동이 발행했을 때 적절한 응답을 하는지 확인하는 테스트
        - 통합 테스트 : 함수나 모듈이 같이 서로 구분되는 영역이 함께 잘 작동하는지 확인하는 테스트
    
    2. Jest 을 사용한 단위 테스트와 통합 테스트
        - 자바스크립트 에서 가장 유명한 test
        - 모듈 설치<br>
            `$ npm i `
        - jest 설치<br>
            ` $npm i jest --save-dev`
        
## 23.11.30    


## 23.11.23
+ ` npm install apollo-server-micro `
+ ` npm install graphql-type-json`

+ <strong>지역 및 전역 상태 관리</strong>
    - 상태 = 동적관리의 일종
        1. 높은 수준의 상호 작용 가능 UI
        2. 더 뛰어난 UX 개발을 위한 필수 요소
    - 상태 관리 로 인해 더 뛰어난 상호 작용 기능 등 구현 가능 BUT 복잡도 증가
    - 리엑트는 클래스 컴포넌트 시절부터 setState 메소드 사용해서 상태 관리
    - 16.8 이후부터는 useState 훅을 포함한 react 훅 제공
    - 리엑트 상태 관리 어려운 이유 = 데이터의 흐름이 단방향
    - 부모 컴포넌트 => 자식에게 속성 형태 전달 가능 BUT 반대는 불가능
    - 지역 상태는 클래스 컴포넌트나 훅 사용애서 어려움 없이 관리 가능 BUT 전역 상태는 단방향의 흐름 때문에 불가능

+ <strong>지역 상태 관리</strong>
    - 지역 상태에서의 앱 상태 = 컴포넌트 스코프 상태
    - Increment 버튼 클릭시 현 count +1, decrement 버튼 클릭시 현 값 -1
    - 부모C 에서는 자식에게 initialCount 라는 속성값을 통해 초기 counter 값 쉽게 전달 가능
    - useState 훅만으로 자식에서 부모로 전달등의 것을 구현 가능
    - < 아톰 컴포넌트> = 지역 상태만 관리
    - < 로딩 상태 > = 지역상태만 관리
        1. 클라이언트 측에서 아직 데이터를 다 읽지 못함 = 전송 HTTP 요청 진행중
        2. 일반적으로 loading 상태값 true 세팅, 전송 요청이 끝날 때 까지 UI 스피너 아이콘 사용

+ <strong>전역 상태 관리</strong>
    - 여려 컴포넌트가 공유하는 상태 의미 = 어떤 컴포넌트라도 접근 및 수정 가능 상태
    - Vue.js, Angular와 다르게 React는 데이터 흐름이 단방향
    - 단방향의 데이터 흐름은 오류발생 가능성 감소, 디버깅 하기 쉽고 효율성 있음 / 앱개발이 더 복잡해지는 단점 보유
    - 전역 상태 관리 대표 라이브러리 = Redux, Recoil 등




## 23.11.16
+ 


## 23.11.09
+ 정적 자원 관리
    - public/ 디렉토리에서 관리
    - 일반적인 웹 어플리케이션 = 이미지, 컴파일 js, 컴파일 css, icon, mani 등의 정적파일에서 사용
+ public/assets/ 디렉토르 생성 후 파일 유형별로 다시 디렉토리 추가
+ 저장된 파일에 접근하고자 하면 예와 같이 public을 제외한 주소 씀

+ 스타일 파일 구성
    - 스타일 파일은 어떤 스타일 관련 기술 사용에 관하여 따라 구성 변화
    - css-in-js 프레임워크의 경우 컴포넌트 별 스타일 파일 생성
+ lib 파일 수성
    - lib 파일 = 서드파티 라이브러리를 감싸는 스크립트
    - lib 파일은 특정 라이브러리에 특화든 것 ex> GraphQL
+ 데이터 불러오기 
    - next는 클라이언트와 서버 모두에서의 데이터를 불러올 수 있음
    - 서버는 2가지 상황에 데이터 불러올 수 있음
        - 정적 페이지 만들 때 getStaticProps 함수 사용시 ,빌드 시점에 데이터 불러올 수 있음
        - 서버 페이지를 렌더링 할 때 getServerSideProps 을 통해 실행 도중 데이터를 불러올 수 있음
    
    - 서버 2가지 방법으로 HTTP 요청을 만들고 처리 가능
        - Node 내장 HTTP 라이브러리
        - HTTP 클라이언트 라이브러리
    - 서버에서 REST API 사용 시
        - PUBLIC API / PRIVATE API 호출에 대한 것 먼저 확인
        - PUBLIC API = 인증 권한 없이 사용가능
        - PRIVATE API = 호출 전 반드시 인증 권한 검사를 갖추어야함 
    
+ SSR-REST-API PROJECT(P97)
    - 새 NEXT PJ 생성 = npx create-next-app ssr-rest-api
    - AXIOS 페이지 추가 $ npm install axios
    - 
    
## 23-11-02
+ 

## 23-10-26
+ 메타 데이터
    - next.js 에서는 내장 head 컴포넌트 제공으로 쉽게 다루기 가능
    - 어떤 컴포넌트에서든 HTML 페이지의 HEAD 내부의 데이터를 변경 추가 삭제 가능
    - 

## 23-10-12
+ 클라이언트에서 내비게이션(p.55)
    - link 컴포넌트를 사용해 서로 다른 페이지 간 이동 최적화
    - 다른 페이지 또는 웹 사이트의 일부를 연결할 때 LINK 컴포넌트 사용
    - link와 연결된 페이지는 이미 클라이언트에 다운 후 => 화면전환 속도 업

+ router.push 메서드 ( 특별한 경우를 제외하고는 추천x, link 권장)
    - LINK 컴폰너트 대신 useRouter Hook 을 사용해 다른 페이지로 이동 가능
    - 로그인 한 사용자만 접근 할 수 있도록 이동시키는 Hook
        - 로그인x 라면 useRouter을 통해 로그인 페이지로 이동
        - router.push 메서드를 사용해 로그인 페이지로 이동
    - Link 와는 다르게 미리 불러오기 불가능

+ 정적 자원 제공
    - 정적 자원은 이미지, 폰트, 아이콘, 컴파일한 css / js 등으로 /public 디렉토리에 저장
    - 정적 자원 중 이미지 파일 => SEO에 많은 영향 미침
    - 불러오는데 시간 많이 걸림, 불러온 후 이미지 주변 레이아웃이 변경되는 등 UX 관점에서 좋지 않은 영향 => 누적 레이아웃 이동(CLS : Cumulatie Layout Shift)
    - Image 컴포넌트를 사용해 위와 같은 문제 해결 가능

+ 자동 이미지 최적화
    - next10부터 이미지 컴포넌트 사용해 이미지 자동 최적화 가능
    - 이 기능 시용시 이미지를 web과 같은 최신 이미지 포맷 지원 가능
    - 최신 포맷 지원 x 브라우저일 경우 png, jpeg 같은 예전 이미지 포맷 지원 가능
    - 필요 시 이미지 크기 조정 가능
    - 특히 클ㄹ라이언트 이미지를 요구할 때 최적화 작업을 한다는 장점 있습니다.
    - 따라서 Unplash 나 Pexel같은 외부 이미지 서비스로 이미지 제공
+ Layout 속성값
    - fixed : 이미지 크기 지정시 화면의 크기 상관없이 이미지 크기 유지
    - responsive : fixed와 반대 방식으로 화면 크기 조절 시 그에 따라 이미지 최적화 후 제공
    - intrinsic : fixed 와 responsive을 절반씩 수용 , 크기 작은 화면에서는 이미지 크기 조절, 이미지보다 큰 화면에서는 이미지 크기 조절x
    - fill : 부모 요소의 가로와 세로 크기 늘림

    

## 23-10-05
+ 정적 사이트 생성(SSG)
    - 일부 또는 전체 페이지를 빌드 시점에 미리 렌더링
    - CSR과 비교할 때 확장성, 뛰어난 성능, 더 안전한 API 요청 면에서 장점이 된다
    - 문제점 : 웹 페이지를 제작 후 다음 배포 전까지 내용 불변 => 수정 필요 시 데이터 가지고 와서 수정하고 다시 생성 과정 반복
    - 중분 정적 재생성(ISR : Incremental Static Regeneration) : 위 문제점 해결 방법
    - 해당 콘텐츠 데이터 로딩 시간 증가시 SSR, ISR 같이 사용 가능
    - 데이터의 변화가 낮다면 SSR 과 ISR 같이 사용하여 데이터 10분 동안 캐싱 가능 
    - getStaticProps 함수 사용

+ Next.js 기초와 내장 컴포넌트
    - next에서는 서버사이드 렌더링 외에도 많은 내장 컴포넌트 함수 제공
    - 3장 => 라우팅 시스템 작동방식, 페이지 간 이동 최적화, next.js가 정적 자원을 제공하는 방법, 이미지 컴포넌트를 사용한 이미지 제공 최적화 기법, HTML 메타데이터 처리 방법, app.js와 documents 파일 내용 커스터마이징 방법

+ 라이팅 시스템
    - react Router, Reach Router 등은 클라이언트 라우팅만 구형 가능
    - Next는 파일시스템 기반 페이지와 라우팅
    - 페이지는 /pages 디렉토리 안에 js, jsx, ts, tsx 파일에서 export 한 React 컴포넌트입니다.

+ 동적 라우팅
    
## 23-09-28 (4주차) - 연휴

## 23-09-21
+ 서버 사이드 렌더링(SSR) 장점
    - 더 안전한 웹 어플리케이션 : 쿠키, API 데이터 관리등의 작업 서버에서 처리 -> 중요 데이터 클라이언트 노출필요X
    - 뛰어난 웹 사이트 호환성 : 클라이언트 환경이 자바스크립트를 사용하지 못하거나 오래된 브라우저를 사용하더라도 서비스 제공 가능
    - 더 뛰어난 SEO : 서버가 렌더링한 HTML을 받기 때문에 봇이나 웹 크롤러가 페이지를 렌더링할 필요 X

+ SSR이 최적의 렌더링 전략이 아닌 경우(권장X 인 경우)
    - 클라이언트가 페이지 요청시 페이지를 다시 렌더링 할 서버 필요
    - 다른 방식에 비해서 SSR이 더 많은 자원 소비, 더 많은 부하, 유지보수 비용 증가
    - 페이지 요청 처리 시간 증가
    - 외부 API 데이터 접근 시 해당 페이지 렌더링 때 이를 다시 요청
    - 페이지 간 이동이 CSR에 비햇 ㅓ느림

+ 클라이언트 사이드 렌더링(CSR)의 이점
    - 네이티브 앱처럼 느껴지는 웹 앱
        1. 다른페이지로 이동해도 서버에 요청 필요없이, 바로 페이지를 이동 가능
        2. 페이지를 바꾸기 위해서 새로고침 필요 없음
        3. 렌더링할 모든 페이지가 이미 브라우저에 다운되어 있음
    - 쉬운 페이지 전환
        1. 클라이언트에서 네비게이션은 브라우저 화면을 새로 고침 팔요 없이 다른 페이지로의 이동 가능하게 함
        2. 페이지 간 전환에 멋진 효과 적용 가능(에니메이션 방해 요소 X)
    - 지연된 로딩과 성능
        1. 웹 앱은 최소의 필요한 HTML만 렌더링
        2. 버튼을 누르면 나오는 모달도 실제 버튼이 누를 때 동적으로 생성
    - 서버 부하 감소
        1. 서버리스 환경에서 제공 가능

+ 클라이언트 사이드 렌더링(CSR)의 단점
    - 네트워크 속도가 느린 환경에서의 번들이 모두 다운될 때 까지 계속 빈 페이지를 적용
    - 번들을 모두 받을 때 까지 범색로봇이 기다리기는 하지만 성능 점수 낮음

+ React.useEffect Hook
    - 최근 리액트 = 함수형 컴포넌트 사용으로 life cycle 함수 대신 Hook 사용
    - 함수형 컴포넌트에서 DOM 조작이나 데이트 불러오기 같은 사이드 이펙트 기능 구현 시 useEffect 함수를 사용하여 컴포넌트가 마운트된 후 해당 기능 실행하도록 만들 수 있음.

+ typeof window 실행
    - 서버에서 실행하면 그 값 = undiefined가 되고 그렇지 않으면 클라이언트 실행


## 23-09-14 (2주차)
## 1장
+ SWC(Speedy Web Compiler)
    - babel 단점
        1. 변환 코드 이해 난해
        2. 변환 코드 길이 증가
        3. 변환 시간 증가
    - swc 장점
        1. 으로 Next12 이후 별도 설정없이 사용가능(Next.js에 내장)
        2. 변환 시간 빠름, Rust의 WASM(WebAssembly) 지원으로 어떤 종류의 플랫폼에서도 개발가능
        3. 주변 자료 활용의 증가 가능성
    
    - 프로젝트 적용 명령어
    + $ npx create-next-app@lastest my-app
    + $ npx create-next-app@12 my-app
        - $npm install next@12 (Next 12 이전 버젼을 사용중일 시 업데이트 진행 좌측 코드는 업데이트 필요 코드)
        - babel 설정시 삭제 필요


## 2장
+ 서버 사이드 렌더링(SSR)
    - APM을 이용한 일반적 웹 페이지 생성
    - 자바스크립트 코드 적재 시 동적 페이지 내용 렌더링
    - Next.js도 동적 페이지 렌더링 가능
    - 스크립트 코드를 넣어 후 웹 페이지 동적 처리 가능 = 하이드레이션
    - 서버 사이드 렌더링 -> 자바스크립트 하이드레이션된 페이지 전송 -> 클라이언트 DOM위 각 스크립트 코드 하이드레이션: 페이지 새로고침없이 상호작용 가능케함


